diff --git a/mtgs.diff b/mtgs.diff
index b067742a2..e69de29bb 100644
--- a/mtgs.diff
+++ b/mtgs.diff
@@ -1,675 +0,0 @@
-diff --git a/pcsx2/GS.cpp b/pcsx2/GS.cpp
-index cb71174ea..afa47532a 100644
---- a/pcsx2/GS.cpp
-+++ b/pcsx2/GS.cpp
-@@ -26,7 +26,7 @@
- using namespace R5900;
- 
- alignas(16) u8 g_RealGSMem[Ps2MemSize::GSregs];
--static bool s_GSRegistersWritten = false;
-+bool s_GSRegistersWritten = false;
- 
- void gsSetVideoMode(GS_VideoMode mode)
- {
-@@ -304,7 +304,6 @@ void gsIrq(void) { hwIntcIrq(INTC_GS); }
- void gsPostVsyncStart(void)
- {
- 	const bool registers_written = s_GSRegistersWritten;
--	s_GSRegistersWritten = false;
- 	MTGS::PostVsyncStart(registers_written);
- }
- 
-diff --git a/pcsx2/GS.h b/pcsx2/GS.h
-index 6d5116656..c66fd3e8c 100644
---- a/pcsx2/GS.h
-+++ b/pcsx2/GS.h
-@@ -300,15 +300,11 @@ namespace MTGS
- 	void WaitGS(bool syncRegs=true, bool weakWait=false, bool isMTVU=false);
- 	void ResetGS(bool hardware_reset);
- 
--	void PrepDataPacket(MTGS_RingCommand cmd, u32 size);
--	void SendDataPacket();
- 	void SendGameCRC(u32 crc);
- 	void WaitForClose();
- 	void Freeze(FreezeAction mode, MTGS_FreezeData& data);
- 
--	void SendSimpleGSPacket(MTGS_RingCommand type, u32 offset, u32 size, GIF_PATH path);
- 	void SendSimplePacket(MTGS_RingCommand type, int data0, int data1, int data2);
--	void SendPointerPacket(MTGS_RingCommand type, u32 data0, void* data1);
- 
- 	void SetEvent();
- 	void PostVsyncStart(bool registers_written);
-@@ -325,7 +321,7 @@ namespace MTGS
- 	bool TryOpenGS();
- 	void CloseGS();
- 
--	void GenericStall(uint size);
-+	void GenericStall();
- };
- 
- /////////////////////////////////////////////////////////////////////////////
-@@ -353,6 +349,7 @@ extern u16 gsRead16(u32 mem);
- extern u32 gsRead32(u32 mem);
- extern u64 gsRead64(u32 mem);
- extern u128 gsNonMirroredRead(u32 mem);
-+extern bool s_GSRegistersWritten;
- 
- void gsIrq();
- 
-@@ -389,20 +386,3 @@ inline void MemCopy_WrappedDest(const u128* src, u128* destBase, uint& destStart
- 		memcpy(destBase, src + firstcopylen, destStart * 16);
- 	}
- }
--
--inline void MemCopy_WrappedSrc(const u128* srcBase, uint& srcStart, uint srcSize, u128* dest, uint len)
--{
--	uint endpos = srcStart + len;
--	if (endpos < srcSize)
--	{
--		memcpy(dest, &srcBase[srcStart], len * 16);
--		srcStart += len;
--	}
--	else
--	{
--		uint firstcopylen = srcSize - srcStart;
--		memcpy(dest, &srcBase[srcStart], firstcopylen * 16);
--		srcStart = endpos % srcSize;
--		memcpy(dest + firstcopylen, srcBase, srcStart * 16);
--	}
--}
-diff --git a/pcsx2/MTGS.cpp b/pcsx2/MTGS.cpp
-index 7c220f88e..02ff718d6 100644
---- a/pcsx2/MTGS.cpp
-+++ b/pcsx2/MTGS.cpp
-@@ -42,18 +42,6 @@ union PacketTagType
- 	};
- };
- 
--struct RingCmdPacket_Vsync
--{
--	u8 regset1[0x0f0];
--	u32 csr;
--	u32 imr;
--	GSRegSIGBLID siglblid;
--
--	// must be 16 byte aligned
--	u32 registers_written;
--	u32 pad[3];
--};
--
- struct MTGS_BufferedData
- {
- 	u128 m_Ring[RingBufferSize];
-@@ -88,13 +76,6 @@ namespace MTGS
- 	// has more than one command in it when the thread is kicked.
- 	static int s_CopyDataTally                      = 0;
- 
--	// These vars maintain instance data for sending Data Packets.
--	// Only one data packet can be constructed and uploaded at a time.
--
--	static uint s_packet_startpos   = 0; // size of the packet (data only, ie. not including the 16 byte command!)
--	static uint s_packet_size       = 0; // size of the packet (data only, ie. not including the 16 byte command!)
--	static uint s_packet_writepos   = 0; // index of the data location in the ringbuffer.
--
- 	static std::thread::id s_thread;
- 	static Threading::ThreadHandle s_thread_handle;
- 	static std::atomic_bool s_open_flag{false};
-@@ -111,37 +92,42 @@ void MTGS::ResetGS(bool hardware_reset)
- 	//  * Signal a reset.
- 	//  * clear the path and byRegs structs (used by GIFtagDummy)
- 
--	s_ReadPos = s_WritePos.load();
--	s_QueuedFrameCount = 0;
-+	s_ReadPos             = s_WritePos.load();
-+	s_QueuedFrameCount    = 0;
- 	s_VsyncSignalListener = 0;
- 
--	SendSimplePacket(GS_RINGTYPE_RESET, static_cast<int>(hardware_reset), 0, 0);
-+	GenericStall();
-+	PacketTagType& tag    = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command           = GS_RINGTYPE_RESET;
-+	tag.data[0]           = static_cast<int>(hardware_reset);
-+	tag.data[1]           = 0;
-+	tag.data[2]           = 0;
-+
-+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++s_CopyDataTally;
- 	SetEvent();
- }
- 
- void MTGS::PostVsyncStart(bool registers_written)
- {
--	// Optimization note: Typically regset1 isn't needed.  The regs in that area are typically
--	// changed infrequently, usually during video mode changes.  However, on modern systems the
--	// 256-byte copy is only a few dozen cycles -- executed 60 times a second -- so probably
--	// not worth the effort or overhead of trying to selectively avoid it.
-+	// Command qword: Low word is the command, and the high word is the packet
-+	// length in SIMDs (128 bits).
- 
--	uint packsize = sizeof(RingCmdPacket_Vsync) / 16;
--	PrepDataPacket(GS_RINGTYPE_VSYNC, packsize);
--	MemCopy_WrappedDest((u128*)PS2MEM_GS, RingBuffer.m_Ring, s_packet_writepos, RingBufferSize, 0xf);
-+	GenericStall();
- 
--	u32* remainder              = (u32*)(u8*)&RingBuffer.m_Ring[s_packet_writepos & RingBufferMask];
--	remainder[0]                = GSCSRr;
--	remainder[1]                = GSIMR._u32;
--	(GSRegSIGBLID&)remainder[2] = GSSIGLBLID;
--	remainder[4]                = static_cast<u32>(registers_written);
--	s_packet_writepos           = (s_packet_writepos + 2) & RingBufferMask;
-+	PacketTagType& tag                = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
-+	tag.command                       = GS_RINGTYPE_VSYNC;
-+	tag.data[0]                       = 0;
- 
--	SendDataPacket();
-+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	s_WritePos.store(future_writepos, std::memory_order_release);
- 
-+	++s_CopyDataTally;
- 	// Vsyncs should always start the GS thread, regardless of how little has actually be queued.
--	if (s_CopyDataTally != 0)
--		SetEvent();
-+	SetEvent();
- 
- 	// If the MTGS is allowed to queue a lot of frames in advance, it creates input lag.
- 	// Use the Queued FrameCount to stall the EE if another vsync (or two) are already queued
-@@ -154,7 +140,7 @@ void MTGS::PostVsyncStart(bool registers_written)
- 	// If those are needed back, it's better to increase the VsyncQueueSize via PCSX_vm.ini.
- 	// (The Xenosaga engine is known to run into this, due to it throwing bulks of data in one frame followed by 2 empty frames.)
- 
--	if ((s_QueuedFrameCount.fetch_add(1) < EmuConfig.GS.VsyncQueueSize))
-+	if ((s_QueuedFrameCount.fetch_add(1) < 0))
- 		return;
- 
- 	s_VsyncSignalListener.store(true, std::memory_order_release);
-@@ -174,7 +160,17 @@ void MTGS::InitAndReadFIFO(u8* mem, u32 qwc)
- 		return;
- 	}
- 
--	SendPointerPacket(GS_RINGTYPE_INIT_AND_READ_FIFO, qwc, mem);
-+	GenericStall();
-+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command          = GS_RINGTYPE_INIT_AND_READ_FIFO;
-+	tag.data[0]          = qwc;
-+	tag.pointer          = (uptr)mem;
-+
-+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++s_CopyDataTally;
- 	WaitGS(false, false, false);
- }
- 
-@@ -182,9 +178,7 @@ bool MTGS::TryOpenGS()
- {
- 	s_thread = std::this_thread::get_id();
- 
--	memcpy(RingBuffer.Regs, PS2MEM_GS, sizeof(PS2MEM_GS));
--
--	if (!GSopen(EmuConfig.GS, EmuConfig.GS.Renderer, RingBuffer.Regs))
-+	if (!GSopen(EmuConfig.GS, EmuConfig.GS.Renderer, PS2MEM_GS))
- 		return false;
- 
- 	GSSetGameCRC(ElfCRC);
-@@ -224,115 +218,90 @@ void MTGS::MainLoop(bool flush_all)
- 		{
- 			const unsigned int local_ReadPos = s_ReadPos.load(std::memory_order_relaxed);
- 			const PacketTagType& tag = (PacketTagType&)RingBuffer.m_Ring[local_ReadPos];
--			u32 ringposinc = 1;
- 
- 			switch (tag.command)
- 			{
- 				case GS_RINGTYPE_GSPACKET:
--				{
--					Gif_Path& path = gifUnit.gifPath[tag.data[2]];
--					u32 offset = tag.data[0];
--					u32 size = tag.data[1];
--					if (offset != ~0u)
--						GSgifTransfer((u8*)&path.buffer[offset], size / 16);
--					path.readAmount.fetch_sub(size, std::memory_order_acq_rel);
--					break;
--				}
--
--				case GS_RINGTYPE_MTVU_GSPACKET:
--				{
--					if (!vu1Thread.semaXGkick.TryWait())
- 					{
--						mtvu_lock.unlock();
--						// Wait for MTVU to complete vu1 program
--						vu1Thread.semaXGkick.Wait();
--						mtvu_lock.lock();
-+						Gif_Path& path = gifUnit.gifPath[tag.data[2]];
-+						u32 offset     = tag.data[0];
-+						u32 size       = tag.data[1];
-+						if (offset != ~0u)
-+							GSgifTransfer((u8*)&path.buffer[offset], size / 16);
-+						path.readAmount.fetch_sub(size, std::memory_order_acq_rel);
-+						break;
- 					}
--					Gif_Path& path = gifUnit.gifPath[GIF_PATH_1];
--					GS_Packet gsPack = path.GetGSPacketMTVU(); // Get vu1 program's xgkick packet(s)
--					if (gsPack.size)
--						GSgifTransfer((u8*)&path.buffer[gsPack.offset], gsPack.size / 16);
--					path.readAmount.fetch_sub(gsPack.size + gsPack.readAmount, std::memory_order_acq_rel);
--					path.PopGSPacketMTVU(); // Should be done last, for proper Gif_MTGS_Wait()
--					break;
--				}
- 
--				default:
--				{
--					switch (tag.command)
-+				case GS_RINGTYPE_MTVU_GSPACKET:
- 					{
--						case GS_RINGTYPE_VSYNC:
-+						if (!vu1Thread.semaXGkick.TryWait())
- 						{
--							const int qsize = tag.data[0];
--							ringposinc += qsize;
--
--							// Mail in the important GS registers.
--							// This seemingly obtuse system is needed in order to handle cases where the vsync data wraps
--							// around the edge of the ringbuffer.  If not for that I'd just use a struct. >_<
--
--							uint datapos = (local_ReadPos + 1) & RingBufferMask;
--							MemCopy_WrappedSrc(RingBuffer.m_Ring, datapos, RingBufferSize, (u128*)RingBuffer.Regs, 0xf);
--
--							u32* remainder = (u32*)&RingBuffer.m_Ring[datapos];
--							((u32&)RingBuffer.Regs[0x1000]) = remainder[0];
--							((u32&)RingBuffer.Regs[0x1010]) = remainder[1];
--							((GSRegSIGBLID&)RingBuffer.Regs[0x1080]) = (GSRegSIGBLID&)remainder[2];
--
--							// CSR & 0x2000; is the pageflip id.
--							if(!flush_all)
--								GSvsync((((u32&)RingBuffer.Regs[0x1000]) & 0x2000) ? 0 : 1, remainder[4] != 0);
--
--							s_QueuedFrameCount.fetch_sub(1);
--							if (s_VsyncSignalListener.exchange(false))
--								s_sem_Vsync.Post();
--
--							// Do not StateCheckInThread() here
--							// Otherwise we could pause while there's still data in the queue
--							// Which could make the MTVU thread wait forever for it to empty
--						}
--						break;
--
--						case GS_RINGTYPE_ASYNC_CALL:
--							{
--								AsyncCallType* const func = (AsyncCallType*)tag.pointer;
--								(*func)();
--								delete func;
--							}
--							break;
--
--						case GS_RINGTYPE_FREEZE:
--						{
--							MTGS_FreezeData* data = (MTGS_FreezeData*)tag.pointer;
--							int mode = tag.data[0];
--							data->retval = GSfreeze((FreezeAction)mode, (freezeData*)data->fdata);
-+							mtvu_lock.unlock();
-+							// Wait for MTVU to complete vu1 program
-+							vu1Thread.semaXGkick.Wait();
-+							mtvu_lock.lock();
- 						}
-+						Gif_Path& path = gifUnit.gifPath[GIF_PATH_1];
-+						GS_Packet gsPack = path.GetGSPacketMTVU(); // Get vu1 program's xgkick packet(s)
-+						if (gsPack.size)
-+							GSgifTransfer((u8*)&path.buffer[gsPack.offset], gsPack.size / 16);
-+						path.readAmount.fetch_sub(gsPack.size + gsPack.readAmount, std::memory_order_acq_rel);
-+						path.PopGSPacketMTVU(); // Should be done last, for proper Gif_MTGS_Wait()
- 						break;
-+					}
-+				case GS_RINGTYPE_VSYNC:
-+					{
-+						// CSR & 0x2000; is the pageflip id.
-+						if(!flush_all)
-+							GSvsync((((u32&)PS2MEM_GS[0x1000]) & 0x2000) ? 0 : 1, s_GSRegistersWritten);
-+						s_GSRegistersWritten = false;
-+
-+						s_QueuedFrameCount.fetch_sub(1);
-+						if (s_VsyncSignalListener.exchange(false))
-+							s_sem_Vsync.Post();
-+
-+						// Do not StateCheckInThread() here
-+						// Otherwise we could pause while there's still data in the queue
-+						// Which could make the MTVU thread wait forever for it to empty
-+					}
-+					break;
-+				case GS_RINGTYPE_ASYNC_CALL:
-+					{
-+						AsyncCallType* const func = (AsyncCallType*)tag.pointer;
-+						(*func)();
-+						delete func;
-+					}
-+					break;
-+				case GS_RINGTYPE_FREEZE:
-+					{
-+						MTGS_FreezeData* data = (MTGS_FreezeData*)tag.pointer;
-+						int mode = tag.data[0];
-+						data->retval = GSfreeze((FreezeAction)mode, (freezeData*)data->fdata);
-+					}
-+					break;
- 
--						case GS_RINGTYPE_RESET:
--							GSreset(tag.data[0] != 0);
--							break;
-+				case GS_RINGTYPE_RESET:
-+					GSreset(tag.data[0] != 0);
-+					break;
- 
--						case GS_RINGTYPE_SOFTRESET:
--							GSgifSoftReset(tag.data[0]);
--							break;
-+				case GS_RINGTYPE_SOFTRESET:
-+					GSgifSoftReset(tag.data[0]);
-+					break;
- 
--						case GS_RINGTYPE_CRC:
--							GSSetGameCRC(tag.data[0]);
--							break;
-+				case GS_RINGTYPE_CRC:
-+					GSSetGameCRC(tag.data[0]);
-+					break;
- 
--						case GS_RINGTYPE_INIT_AND_READ_FIFO:
--							GSInitAndReadFIFO((u8*)tag.pointer, tag.data[0]);
--							break;
-+				case GS_RINGTYPE_INIT_AND_READ_FIFO:
-+					GSInitAndReadFIFO((u8*)tag.pointer, tag.data[0]);
-+					break;
- 
--							// Optimized performance in non-Dev builds.
--						default:
--							break;
--					}
--				}
-+					// Optimized performance in non-Dev builds.
-+				default:
-+					break;
- 			}
- 
--			uint newringpos = (s_ReadPos.load(std::memory_order_relaxed) + ringposinc) & RingBufferMask;
--
-+			uint newringpos = (local_ReadPos + 1) & RingBufferMask;
- 			s_ReadPos.store(newringpos, std::memory_order_release);
- 
- 			if(!flush_all && tag.command == GS_RINGTYPE_VSYNC) {
-@@ -343,7 +312,7 @@ void MTGS::MainLoop(bool flush_all)
- 			if (s_SignalRingEnable.load(std::memory_order_acquire))
- 			{
- 				// The EEcore has requested a signal after some amount of processed data.
--				if (s_SignalRingPosition.fetch_sub(ringposinc) <= 0)
-+				if (s_SignalRingPosition.fetch_sub(1) <= 0)
- 				{
- 					// Make sure to post the signal after the m_ReadPos has been updated...
- 					s_SignalRingEnable.store(false, std::memory_order_release);
-@@ -438,10 +407,6 @@ void MTGS::WaitGS(bool syncRegs, bool weakWait, bool isMTVU)
- 		if (!s_sem_event.WaitForEmpty())
- 			Console.Error("MTGS Thread Died");
- 	}
--
--	// Completely synchronize GS and MTGS register states.
--	if (syncRegs)
--		memcpy(RingBuffer.Regs, PS2MEM_GS, sizeof(RingBuffer.Regs));
- }
- 
- // Sets the gsEvent flag and releases a timeslice.
-@@ -452,23 +417,7 @@ void MTGS::SetEvent()
- 	s_CopyDataTally = 0;
- }
- 
--// Closes the data packet send command, and initiates the gs thread (if needed).
--void MTGS::SendDataPacket()
--{
--	uint actualSize    = ((s_packet_writepos - s_packet_startpos) & RingBufferMask) - 1;
--	PacketTagType& tag = (PacketTagType&)RingBuffer.m_Ring[s_packet_startpos];
--	tag.data[0]        = actualSize;
--
--	s_WritePos.store(s_packet_writepos, std::memory_order_release);
--
--	s_CopyDataTally += s_packet_size;
--	if (s_CopyDataTally > 0x2000)
--		SetEvent();
--
--	s_packet_size = 0;
--}
--
--void MTGS::GenericStall(uint size)
-+void MTGS::GenericStall()
- {
- 	// Note on volatiles: s_WritePos is not modified by the GS thread, so there's no need
- 	// to use volatile reads here.  We do cache it though, since we know it never changes,
-@@ -478,7 +427,7 @@ void MTGS::GenericStall(uint size)
- 	// generic gs wait/stall.
- 	// if the writepos is past the readpos then we're safe.
- 	// But if not then we need to make sure the readpos is outside the scope of
--	// the block about to be written (writepos + size)
-+	// the block about to be written (writepos + 1)
- 
- 	uint readpos = s_ReadPos.load(std::memory_order_acquire);
- 	uint freeroom;
-@@ -488,7 +437,7 @@ void MTGS::GenericStall(uint size)
- 	else
- 		freeroom = RingBufferSize - (writepos - readpos);
- 
--	if (freeroom <= size)
-+	if (freeroom <= 1)
- 	{
- 		// writepos will overlap readpos if we commit the data, so we need to wait until
- 		// readpos is out past the end of the future write pos, or until it wraps around
-@@ -499,8 +448,8 @@ void MTGS::GenericStall(uint size)
- 		// thread to wake up the EE once there's a sizable chunk of the ringbuffer emptied.
- 
- 		uint somedone = (RingBufferSize - freeroom) / 4;
--		if (somedone < size + 1)
--			somedone = size + 1;
-+		if (somedone < 2)
-+			somedone = 2;
- 
- 		// FMV Optimization: FMVs typically send *very* little data to the GS, in some cases
- 		// every other frame is nothing more than a page swap.  Sleeping the EEcore is a
-@@ -521,7 +470,7 @@ void MTGS::GenericStall(uint size)
- 				else
- 					freeroom = RingBufferSize - (writepos - readpos);
- 
--				if (freeroom > size)
-+				if (freeroom > 1)
- 					break;
- 			}
- 		}
-@@ -538,63 +487,39 @@ void MTGS::GenericStall(uint size)
- 				else
- 					freeroom = RingBufferSize - (writepos - readpos);
- 
--				if (freeroom > size)
-+				if (freeroom > 1)
- 					break;
- 			}
- 		}
- 	}
- }
- 
--void MTGS::PrepDataPacket(MTGS_RingCommand cmd, u32 size)
--{
--	s_packet_size = size;
--	++size; // takes into account our RingCommand QWC.
--	GenericStall(size);
--
--	// Command qword: Low word is the command, and the high word is the packet
--	// length in SIMDs (128 bits).
--	const unsigned int local_WritePos = s_WritePos.load(std::memory_order_relaxed);
--
--	PacketTagType& tag = (PacketTagType&)RingBuffer.m_Ring[local_WritePos];
--	tag.command        = cmd;
--	tag.data[0]        = s_packet_size;
--	s_packet_startpos  = local_WritePos;
--	s_packet_writepos  = (local_WritePos + 1) & RingBufferMask;
--}
--
- void MTGS::SendSimplePacket(MTGS_RingCommand type, int data0, int data1, int data2)
- {
--	GenericStall(1);
--	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
-+       GenericStall();
-+       PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
- 
--	tag.command          = type;
--	tag.data[0]          = data0;
--	tag.data[1]          = data1;
--	tag.data[2]          = data2;
-+       tag.command          = type;
-+       tag.data[0]          = data0;
-+       tag.data[1]          = data1;
-+       tag.data[2]          = data2;
- 
--	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
--	s_WritePos.store(future_writepos, std::memory_order_release);
-+       uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+       s_WritePos.store(future_writepos, std::memory_order_release);
- 
--	++s_CopyDataTally;
-+       ++s_CopyDataTally;
- }
- 
--void MTGS::SendSimpleGSPacket(MTGS_RingCommand type, u32 offset, u32 size, GIF_PATH path)
--{
--	SendSimplePacket(type, (int)offset, (int)size, (int)path);
- 
--	s_CopyDataTally += size / 16;
--	if (s_CopyDataTally > 0x2000)
--		SetEvent();
--}
--
--void MTGS::SendPointerPacket(MTGS_RingCommand type, u32 data0, void* data1)
-+void MTGS::SendGameCRC(u32 crc)
- {
--	GenericStall(1);
-+	GenericStall();
- 	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
- 
--	tag.command          = type;
--	tag.data[0]          = data0;
--	tag.pointer          = (uptr)data1;
-+	tag.command          = GS_RINGTYPE_CRC;
-+	tag.data[0]          = crc;
-+	tag.data[1]          = 0;
-+	tag.data[2]          = 0;
- 
- 	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
- 	s_WritePos.store(future_writepos, std::memory_order_release);
-@@ -602,11 +527,6 @@ void MTGS::SendPointerPacket(MTGS_RingCommand type, u32 data0, void* data1)
- 	++s_CopyDataTally;
- }
- 
--void MTGS::SendGameCRC(u32 crc)
--{
--	SendSimplePacket(GS_RINGTYPE_CRC, crc, 0, 0);
--}
--
- void MTGS::WaitForClose()
- {
- 	// and kick the thread if it's sleeping
-@@ -624,13 +544,33 @@ void MTGS::Freeze(FreezeAction mode, MTGS_FreezeData& data)
- 	if (mode == FreezeAction::Load)
- 		WaitGS(true);
- 
--	SendPointerPacket(GS_RINGTYPE_FREEZE, (int)mode, &data);
-+	GenericStall();
-+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command          = GS_RINGTYPE_FREEZE;
-+	tag.data[0]          = (int)mode;
-+	tag.pointer          = (uptr)&data;
-+
-+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++s_CopyDataTally;
- 	WaitGS(false);
- }
- 
- void MTGS::RunOnGSThread(AsyncCallType func)
- {
--	SendPointerPacket(GS_RINGTYPE_ASYNC_CALL, 0, new AsyncCallType(std::move(func)));
-+	GenericStall();
-+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command          = GS_RINGTYPE_ASYNC_CALL;
-+	tag.data[0]          = 0;
-+	tag.pointer          = (uptr)new AsyncCallType(std::move(func));
-+
-+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++s_CopyDataTally;
- 
- 	// wake the gs thread in case it's sleeping
- 	SetEvent();
-@@ -681,18 +621,61 @@ void MTGS::ToggleSoftwareRendering()
- // Used in MTVU mode... MTVU will later complete a real packet
- void Gif_AddGSPacketMTVU(GS_Packet& gsPack, GIF_PATH path)
- {
--	MTGS::SendSimpleGSPacket(GS_RINGTYPE_MTVU_GSPACKET, 0, 0, path);
-+	MTGS::GenericStall();
-+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[MTGS::s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command          = GS_RINGTYPE_MTVU_GSPACKET;
-+	tag.data[0]          = 0;
-+	tag.data[1]          = 0;
-+	tag.data[2]          = (int)path;
-+
-+	uint future_writepos = (MTGS::s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	MTGS::s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++MTGS::s_CopyDataTally;
-+	if (MTGS::s_CopyDataTally > 0x2000)
-+		MTGS::SetEvent();
- }
- 
- void Gif_AddCompletedGSPacket(GS_Packet& gsPack, GIF_PATH path)
- {
- 	gifUnit.gifPath[path].readAmount.fetch_add(gsPack.size);
--	MTGS::SendSimpleGSPacket(GS_RINGTYPE_GSPACKET, gsPack.offset, gsPack.size, path);
-+	MTGS::GenericStall();
-+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[MTGS::s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command          = GS_RINGTYPE_GSPACKET;
-+	tag.data[0]          = (int)gsPack.offset;
-+	tag.data[1]          = (int)gsPack.size;
-+	tag.data[2]          = (int)path;
-+
-+	uint future_writepos = (MTGS::s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	MTGS::s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++MTGS::s_CopyDataTally;
-+
-+	MTGS::s_CopyDataTally += gsPack.size / 16;
-+	if (MTGS::s_CopyDataTally > 0x2000)
-+		MTGS::SetEvent();
- }
- 
- void Gif_AddBlankGSPacket(u32 size, GIF_PATH path)
- {
- 	gifUnit.gifPath[path].readAmount.fetch_add(size);
--	MTGS::SendSimpleGSPacket(GS_RINGTYPE_GSPACKET, ~0u, size, path);
-+	MTGS::GenericStall();
-+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[MTGS::s_WritePos.load(std::memory_order_relaxed)];
-+
-+	tag.command          = GS_RINGTYPE_GSPACKET;
-+	tag.data[0]          = (int)~0u;
-+	tag.data[1]          = (int)size;
-+	tag.data[2]          = (int)path;
-+
-+	uint future_writepos = (MTGS::s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-+	MTGS::s_WritePos.store(future_writepos, std::memory_order_release);
-+
-+	++MTGS::s_CopyDataTally;
-+
-+	MTGS::s_CopyDataTally += size;
-+	if (MTGS::s_CopyDataTally > 0x2000)
-+		MTGS::SetEvent();
- }
- 
diff --git a/pcsx2/GS.cpp b/pcsx2/GS.cpp
index cb71174ea..afa47532a 100644
--- a/pcsx2/GS.cpp
+++ b/pcsx2/GS.cpp
@@ -26,7 +26,7 @@
 using namespace R5900;
 
 alignas(16) u8 g_RealGSMem[Ps2MemSize::GSregs];
-static bool s_GSRegistersWritten = false;
+bool s_GSRegistersWritten = false;
 
 void gsSetVideoMode(GS_VideoMode mode)
 {
@@ -304,7 +304,6 @@ void gsIrq(void) { hwIntcIrq(INTC_GS); }
 void gsPostVsyncStart(void)
 {
 	const bool registers_written = s_GSRegistersWritten;
-	s_GSRegistersWritten = false;
 	MTGS::PostVsyncStart(registers_written);
 }
 
diff --git a/pcsx2/GS.h b/pcsx2/GS.h
index 6d5116656..a408f7bf2 100644
--- a/pcsx2/GS.h
+++ b/pcsx2/GS.h
@@ -283,7 +283,6 @@ enum MTGS_RingCommand
 struct MTGS_FreezeData
 {
 	freezeData* fdata;
-	s32 retval; // value returned from the call, valid only after an mtgsWaitGS()
 };
 
 // --------------------------------------------------------------------------------------
@@ -297,18 +296,14 @@ namespace MTGS
 	bool IsOpen();
 
 	// Waits for the GS to empty out the entire ring buffer contents.
-	void WaitGS(bool syncRegs=true, bool weakWait=false, bool isMTVU=false);
+	void WaitGS(bool weakWait, bool isMTVU);
 	void ResetGS(bool hardware_reset);
 
-	void PrepDataPacket(MTGS_RingCommand cmd, u32 size);
-	void SendDataPacket();
 	void SendGameCRC(u32 crc);
 	void WaitForClose();
 	void Freeze(FreezeAction mode, MTGS_FreezeData& data);
 
-	void SendSimpleGSPacket(MTGS_RingCommand type, u32 offset, u32 size, GIF_PATH path);
 	void SendSimplePacket(MTGS_RingCommand type, int data0, int data1, int data2);
-	void SendPointerPacket(MTGS_RingCommand type, u32 data0, void* data1);
 
 	void SetEvent();
 	void PostVsyncStart(bool registers_written);
@@ -325,7 +320,7 @@ namespace MTGS
 	bool TryOpenGS();
 	void CloseGS();
 
-	void GenericStall(uint size);
+	void GenericStall();
 };
 
 /////////////////////////////////////////////////////////////////////////////
@@ -353,6 +348,7 @@ extern u16 gsRead16(u32 mem);
 extern u32 gsRead32(u32 mem);
 extern u64 gsRead64(u32 mem);
 extern u128 gsNonMirroredRead(u32 mem);
+extern bool s_GSRegistersWritten;
 
 void gsIrq();
 
@@ -389,20 +385,3 @@ inline void MemCopy_WrappedDest(const u128* src, u128* destBase, uint& destStart
 		memcpy(destBase, src + firstcopylen, destStart * 16);
 	}
 }
-
-inline void MemCopy_WrappedSrc(const u128* srcBase, uint& srcStart, uint srcSize, u128* dest, uint len)
-{
-	uint endpos = srcStart + len;
-	if (endpos < srcSize)
-	{
-		memcpy(dest, &srcBase[srcStart], len * 16);
-		srcStart += len;
-	}
-	else
-	{
-		uint firstcopylen = srcSize - srcStart;
-		memcpy(dest, &srcBase[srcStart], firstcopylen * 16);
-		srcStart = endpos % srcSize;
-		memcpy(dest + firstcopylen, srcBase, srcStart * 16);
-	}
-}
diff --git a/pcsx2/Gif_Unit.cpp b/pcsx2/Gif_Unit.cpp
index e45b8fd3a..b5b6b8caf 100644
--- a/pcsx2/Gif_Unit.cpp
+++ b/pcsx2/Gif_Unit.cpp
@@ -164,7 +164,7 @@ bool SaveStateBase::gifPathFreeze(u32 path)
 bool SaveStateBase::gifFreeze(void)
 {
 	bool mtvuMode = THREAD_VU1;
-	MTGS::WaitGS();
+	MTGS::WaitGS(false, false);
 	if (!(FreezeTag("Gif Unit")))
 		return false;
 
diff --git a/pcsx2/Gif_Unit.h b/pcsx2/Gif_Unit.h
index caa432284..693d0dcca 100644
--- a/pcsx2/Gif_Unit.h
+++ b/pcsx2/Gif_Unit.h
@@ -262,7 +262,7 @@ struct Gif_Path
 			s32 frontFree = offset - getReadAmount();
 			if (frontFree >= sizeToAdd - intersect)
 				break;
-			MTGS::WaitGS(false, true, isMTVU());
+			MTGS::WaitGS(true, isMTVU());
 		}
 		if (offset < (s32)buffLimit)
 		{ // Needed for correct readAmount values
@@ -294,7 +294,7 @@ struct Gif_Path
 				break; // MTGS is reading in back of curOffset
 			if ((s32)buffLimit + readPos > (s32)curSize + (s32)size)
 				break;      // Enough free front space
-			MTGS::WaitGS(false, true, isMTVU()); // Let MTGS run to free up buffer space
+			MTGS::WaitGS(true, isMTVU()); // Let MTGS run to free up buffer space
 		}
 		memcpy(&buffer[curSize], pMem, size);
 		curSize += size;
diff --git a/pcsx2/MTGS.cpp b/pcsx2/MTGS.cpp
index 7c220f88e..a42b0494d 100644
--- a/pcsx2/MTGS.cpp
+++ b/pcsx2/MTGS.cpp
@@ -42,18 +42,6 @@ union PacketTagType
 	};
 };
 
-struct RingCmdPacket_Vsync
-{
-	u8 regset1[0x0f0];
-	u32 csr;
-	u32 imr;
-	GSRegSIGBLID siglblid;
-
-	// must be 16 byte aligned
-	u32 registers_written;
-	u32 pad[3];
-};
-
 struct MTGS_BufferedData
 {
 	u128 m_Ring[RingBufferSize];
@@ -88,13 +76,6 @@ namespace MTGS
 	// has more than one command in it when the thread is kicked.
 	static int s_CopyDataTally                      = 0;
 
-	// These vars maintain instance data for sending Data Packets.
-	// Only one data packet can be constructed and uploaded at a time.
-
-	static uint s_packet_startpos   = 0; // size of the packet (data only, ie. not including the 16 byte command!)
-	static uint s_packet_size       = 0; // size of the packet (data only, ie. not including the 16 byte command!)
-	static uint s_packet_writepos   = 0; // index of the data location in the ringbuffer.
-
 	static std::thread::id s_thread;
 	static Threading::ThreadHandle s_thread_handle;
 	static std::atomic_bool s_open_flag{false};
@@ -111,37 +92,42 @@ void MTGS::ResetGS(bool hardware_reset)
 	//  * Signal a reset.
 	//  * clear the path and byRegs structs (used by GIFtagDummy)
 
-	s_ReadPos = s_WritePos.load();
-	s_QueuedFrameCount = 0;
+	s_ReadPos             = s_WritePos.load();
+	s_QueuedFrameCount    = 0;
 	s_VsyncSignalListener = 0;
 
-	SendSimplePacket(GS_RINGTYPE_RESET, static_cast<int>(hardware_reset), 0, 0);
+	GenericStall();
+	PacketTagType& tag    = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command           = GS_RINGTYPE_RESET;
+	tag.data[0]           = static_cast<int>(hardware_reset);
+	tag.data[1]           = 0;
+	tag.data[2]           = 0;
+
+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++s_CopyDataTally;
 	SetEvent();
 }
 
 void MTGS::PostVsyncStart(bool registers_written)
 {
-	// Optimization note: Typically regset1 isn't needed.  The regs in that area are typically
-	// changed infrequently, usually during video mode changes.  However, on modern systems the
-	// 256-byte copy is only a few dozen cycles -- executed 60 times a second -- so probably
-	// not worth the effort or overhead of trying to selectively avoid it.
+	// Command qword: Low word is the command, and the high word is the packet
+	// length in SIMDs (128 bits).
 
-	uint packsize = sizeof(RingCmdPacket_Vsync) / 16;
-	PrepDataPacket(GS_RINGTYPE_VSYNC, packsize);
-	MemCopy_WrappedDest((u128*)PS2MEM_GS, RingBuffer.m_Ring, s_packet_writepos, RingBufferSize, 0xf);
+	GenericStall();
 
-	u32* remainder              = (u32*)(u8*)&RingBuffer.m_Ring[s_packet_writepos & RingBufferMask];
-	remainder[0]                = GSCSRr;
-	remainder[1]                = GSIMR._u32;
-	(GSRegSIGBLID&)remainder[2] = GSSIGLBLID;
-	remainder[4]                = static_cast<u32>(registers_written);
-	s_packet_writepos           = (s_packet_writepos + 2) & RingBufferMask;
+	PacketTagType& tag                = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
+	tag.command                       = GS_RINGTYPE_VSYNC;
+	tag.data[0]                       = 0;
 
-	SendDataPacket();
+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	s_WritePos.store(future_writepos, std::memory_order_release);
 
+	++s_CopyDataTally;
 	// Vsyncs should always start the GS thread, regardless of how little has actually be queued.
-	if (s_CopyDataTally != 0)
-		SetEvent();
+	SetEvent();
 
 	// If the MTGS is allowed to queue a lot of frames in advance, it creates input lag.
 	// Use the Queued FrameCount to stall the EE if another vsync (or two) are already queued
@@ -154,7 +140,7 @@ void MTGS::PostVsyncStart(bool registers_written)
 	// If those are needed back, it's better to increase the VsyncQueueSize via PCSX_vm.ini.
 	// (The Xenosaga engine is known to run into this, due to it throwing bulks of data in one frame followed by 2 empty frames.)
 
-	if ((s_QueuedFrameCount.fetch_add(1) < EmuConfig.GS.VsyncQueueSize))
+	if ((s_QueuedFrameCount.fetch_add(1) < 0))
 		return;
 
 	s_VsyncSignalListener.store(true, std::memory_order_release);
@@ -174,17 +160,25 @@ void MTGS::InitAndReadFIFO(u8* mem, u32 qwc)
 		return;
 	}
 
-	SendPointerPacket(GS_RINGTYPE_INIT_AND_READ_FIFO, qwc, mem);
-	WaitGS(false, false, false);
+	GenericStall();
+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command          = GS_RINGTYPE_INIT_AND_READ_FIFO;
+	tag.data[0]          = qwc;
+	tag.pointer          = (uptr)mem;
+
+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++s_CopyDataTally;
+	WaitGS(false, false);
 }
 
 bool MTGS::TryOpenGS()
 {
 	s_thread = std::this_thread::get_id();
 
-	memcpy(RingBuffer.Regs, PS2MEM_GS, sizeof(PS2MEM_GS));
-
-	if (!GSopen(EmuConfig.GS, EmuConfig.GS.Renderer, RingBuffer.Regs))
+	if (!GSopen(EmuConfig.GS, EmuConfig.GS.Renderer, PS2MEM_GS))
 		return false;
 
 	GSSetGameCRC(ElfCRC);
@@ -224,115 +218,90 @@ void MTGS::MainLoop(bool flush_all)
 		{
 			const unsigned int local_ReadPos = s_ReadPos.load(std::memory_order_relaxed);
 			const PacketTagType& tag = (PacketTagType&)RingBuffer.m_Ring[local_ReadPos];
-			u32 ringposinc = 1;
 
 			switch (tag.command)
 			{
 				case GS_RINGTYPE_GSPACKET:
-				{
-					Gif_Path& path = gifUnit.gifPath[tag.data[2]];
-					u32 offset = tag.data[0];
-					u32 size = tag.data[1];
-					if (offset != ~0u)
-						GSgifTransfer((u8*)&path.buffer[offset], size / 16);
-					path.readAmount.fetch_sub(size, std::memory_order_acq_rel);
-					break;
-				}
-
-				case GS_RINGTYPE_MTVU_GSPACKET:
-				{
-					if (!vu1Thread.semaXGkick.TryWait())
 					{
-						mtvu_lock.unlock();
-						// Wait for MTVU to complete vu1 program
-						vu1Thread.semaXGkick.Wait();
-						mtvu_lock.lock();
+						Gif_Path& path = gifUnit.gifPath[tag.data[2]];
+						u32 offset     = tag.data[0];
+						u32 size       = tag.data[1];
+						if (offset != ~0u)
+							GSgifTransfer((u8*)&path.buffer[offset], size / 16);
+						path.readAmount.fetch_sub(size, std::memory_order_acq_rel);
+						break;
 					}
-					Gif_Path& path = gifUnit.gifPath[GIF_PATH_1];
-					GS_Packet gsPack = path.GetGSPacketMTVU(); // Get vu1 program's xgkick packet(s)
-					if (gsPack.size)
-						GSgifTransfer((u8*)&path.buffer[gsPack.offset], gsPack.size / 16);
-					path.readAmount.fetch_sub(gsPack.size + gsPack.readAmount, std::memory_order_acq_rel);
-					path.PopGSPacketMTVU(); // Should be done last, for proper Gif_MTGS_Wait()
-					break;
-				}
 
-				default:
-				{
-					switch (tag.command)
+				case GS_RINGTYPE_MTVU_GSPACKET:
 					{
-						case GS_RINGTYPE_VSYNC:
-						{
-							const int qsize = tag.data[0];
-							ringposinc += qsize;
-
-							// Mail in the important GS registers.
-							// This seemingly obtuse system is needed in order to handle cases where the vsync data wraps
-							// around the edge of the ringbuffer.  If not for that I'd just use a struct. >_<
-
-							uint datapos = (local_ReadPos + 1) & RingBufferMask;
-							MemCopy_WrappedSrc(RingBuffer.m_Ring, datapos, RingBufferSize, (u128*)RingBuffer.Regs, 0xf);
-
-							u32* remainder = (u32*)&RingBuffer.m_Ring[datapos];
-							((u32&)RingBuffer.Regs[0x1000]) = remainder[0];
-							((u32&)RingBuffer.Regs[0x1010]) = remainder[1];
-							((GSRegSIGBLID&)RingBuffer.Regs[0x1080]) = (GSRegSIGBLID&)remainder[2];
-
-							// CSR & 0x2000; is the pageflip id.
-							if(!flush_all)
-								GSvsync((((u32&)RingBuffer.Regs[0x1000]) & 0x2000) ? 0 : 1, remainder[4] != 0);
-
-							s_QueuedFrameCount.fetch_sub(1);
-							if (s_VsyncSignalListener.exchange(false))
-								s_sem_Vsync.Post();
-
-							// Do not StateCheckInThread() here
-							// Otherwise we could pause while there's still data in the queue
-							// Which could make the MTVU thread wait forever for it to empty
-						}
-						break;
-
-						case GS_RINGTYPE_ASYNC_CALL:
-							{
-								AsyncCallType* const func = (AsyncCallType*)tag.pointer;
-								(*func)();
-								delete func;
-							}
-							break;
-
-						case GS_RINGTYPE_FREEZE:
+						if (!vu1Thread.semaXGkick.TryWait())
 						{
-							MTGS_FreezeData* data = (MTGS_FreezeData*)tag.pointer;
-							int mode = tag.data[0];
-							data->retval = GSfreeze((FreezeAction)mode, (freezeData*)data->fdata);
+							mtvu_lock.unlock();
+							// Wait for MTVU to complete vu1 program
+							vu1Thread.semaXGkick.Wait();
+							mtvu_lock.lock();
 						}
+						Gif_Path& path = gifUnit.gifPath[GIF_PATH_1];
+						GS_Packet gsPack = path.GetGSPacketMTVU(); // Get vu1 program's xgkick packet(s)
+						if (gsPack.size)
+							GSgifTransfer((u8*)&path.buffer[gsPack.offset], gsPack.size / 16);
+						path.readAmount.fetch_sub(gsPack.size + gsPack.readAmount, std::memory_order_acq_rel);
+						path.PopGSPacketMTVU(); // Should be done last, for proper Gif_MTGS_Wait()
 						break;
+					}
+				case GS_RINGTYPE_VSYNC:
+					{
+						// CSR & 0x2000; is the pageflip id.
+						if(!flush_all)
+							GSvsync((((u32&)PS2MEM_GS[0x1000]) & 0x2000) ? 0 : 1, s_GSRegistersWritten);
+						s_GSRegistersWritten = false;
+
+						s_QueuedFrameCount.fetch_sub(1);
+						if (s_VsyncSignalListener.exchange(false))
+							s_sem_Vsync.Post();
+
+						// Do not StateCheckInThread() here
+						// Otherwise we could pause while there's still data in the queue
+						// Which could make the MTVU thread wait forever for it to empty
+					}
+					break;
+				case GS_RINGTYPE_ASYNC_CALL:
+					{
+						AsyncCallType* const func = (AsyncCallType*)tag.pointer;
+						(*func)();
+						delete func;
+					}
+					break;
+				case GS_RINGTYPE_FREEZE:
+					{
+						MTGS_FreezeData* data = (MTGS_FreezeData*)tag.pointer;
+						int mode = tag.data[0];
+						GSfreeze((FreezeAction)mode, (freezeData*)data->fdata);
+					}
+					break;
 
-						case GS_RINGTYPE_RESET:
-							GSreset(tag.data[0] != 0);
-							break;
+				case GS_RINGTYPE_RESET:
+					GSreset(tag.data[0] != 0);
+					break;
 
-						case GS_RINGTYPE_SOFTRESET:
-							GSgifSoftReset(tag.data[0]);
-							break;
+				case GS_RINGTYPE_SOFTRESET:
+					GSgifSoftReset(tag.data[0]);
+					break;
 
-						case GS_RINGTYPE_CRC:
-							GSSetGameCRC(tag.data[0]);
-							break;
+				case GS_RINGTYPE_CRC:
+					GSSetGameCRC(tag.data[0]);
+					break;
 
-						case GS_RINGTYPE_INIT_AND_READ_FIFO:
-							GSInitAndReadFIFO((u8*)tag.pointer, tag.data[0]);
-							break;
+				case GS_RINGTYPE_INIT_AND_READ_FIFO:
+					GSInitAndReadFIFO((u8*)tag.pointer, tag.data[0]);
+					break;
 
-							// Optimized performance in non-Dev builds.
-						default:
-							break;
-					}
-				}
+					// Optimized performance in non-Dev builds.
+				default:
+					break;
 			}
 
-			uint newringpos = (s_ReadPos.load(std::memory_order_relaxed) + ringposinc) & RingBufferMask;
-
+			uint newringpos = (local_ReadPos + 1) & RingBufferMask;
 			s_ReadPos.store(newringpos, std::memory_order_release);
 
 			if(!flush_all && tag.command == GS_RINGTYPE_VSYNC) {
@@ -343,7 +312,7 @@ void MTGS::MainLoop(bool flush_all)
 			if (s_SignalRingEnable.load(std::memory_order_acquire))
 			{
 				// The EEcore has requested a signal after some amount of processed data.
-				if (s_SignalRingPosition.fetch_sub(ringposinc) <= 0)
+				if (s_SignalRingPosition.fetch_sub(1) <= 0)
 				{
 					// Make sure to post the signal after the m_ReadPos has been updated...
 					s_SignalRingEnable.store(false, std::memory_order_release);
@@ -391,10 +360,9 @@ void MTGS::CloseGS()
 }
 
 // Waits for the GS to empty out the entire ring buffer contents.
-// If syncRegs, then writes pcsx2's gs regs to MTGS's internal copy
 // If weakWait, then this function is allowed to exit after MTGS finished a path1 packet
 // If isMTVU, then this implies this function is being called from the MTVU thread...
-void MTGS::WaitGS(bool syncRegs, bool weakWait, bool isMTVU)
+void MTGS::WaitGS(bool weakWait, bool isMTVU)
 {
 	if(std::this_thread::get_id() == s_thread)
 	{
@@ -407,14 +375,13 @@ void MTGS::WaitGS(bool syncRegs, bool weakWait, bool isMTVU)
 		return;
 	}
 
-	Gif_Path& path = gifUnit.gifPath[GIF_PATH_1];
-
 	// Both s_ReadPos and s_WritePos can be relaxed as we only want to test if the queue is empty but
 	// we don't want to access the content of the queue
 
 	SetEvent();
 	if (weakWait && isMTVU)
 	{
+		Gif_Path& path = gifUnit.gifPath[GIF_PATH_1];
 		// On weakWait we will stop waiting on the MTGS thread if the
 		// MTGS thread has processed a vu1 xgkick packet, or is pending on
 		// its final vu1 xgkick packet (!curP1Packs)...
@@ -438,10 +405,6 @@ void MTGS::WaitGS(bool syncRegs, bool weakWait, bool isMTVU)
 		if (!s_sem_event.WaitForEmpty())
 			Console.Error("MTGS Thread Died");
 	}
-
-	// Completely synchronize GS and MTGS register states.
-	if (syncRegs)
-		memcpy(RingBuffer.Regs, PS2MEM_GS, sizeof(RingBuffer.Regs));
 }
 
 // Sets the gsEvent flag and releases a timeslice.
@@ -452,23 +415,7 @@ void MTGS::SetEvent()
 	s_CopyDataTally = 0;
 }
 
-// Closes the data packet send command, and initiates the gs thread (if needed).
-void MTGS::SendDataPacket()
-{
-	uint actualSize    = ((s_packet_writepos - s_packet_startpos) & RingBufferMask) - 1;
-	PacketTagType& tag = (PacketTagType&)RingBuffer.m_Ring[s_packet_startpos];
-	tag.data[0]        = actualSize;
-
-	s_WritePos.store(s_packet_writepos, std::memory_order_release);
-
-	s_CopyDataTally += s_packet_size;
-	if (s_CopyDataTally > 0x2000)
-		SetEvent();
-
-	s_packet_size = 0;
-}
-
-void MTGS::GenericStall(uint size)
+void MTGS::GenericStall()
 {
 	// Note on volatiles: s_WritePos is not modified by the GS thread, so there's no need
 	// to use volatile reads here.  We do cache it though, since we know it never changes,
@@ -478,7 +425,7 @@ void MTGS::GenericStall(uint size)
 	// generic gs wait/stall.
 	// if the writepos is past the readpos then we're safe.
 	// But if not then we need to make sure the readpos is outside the scope of
-	// the block about to be written (writepos + size)
+	// the block about to be written (writepos + 1)
 
 	uint readpos = s_ReadPos.load(std::memory_order_acquire);
 	uint freeroom;
@@ -488,7 +435,7 @@ void MTGS::GenericStall(uint size)
 	else
 		freeroom = RingBufferSize - (writepos - readpos);
 
-	if (freeroom <= size)
+	if (freeroom <= 1)
 	{
 		// writepos will overlap readpos if we commit the data, so we need to wait until
 		// readpos is out past the end of the future write pos, or until it wraps around
@@ -499,8 +446,8 @@ void MTGS::GenericStall(uint size)
 		// thread to wake up the EE once there's a sizable chunk of the ringbuffer emptied.
 
 		uint somedone = (RingBufferSize - freeroom) / 4;
-		if (somedone < size + 1)
-			somedone = size + 1;
+		if (somedone < 2)
+			somedone = 2;
 
 		// FMV Optimization: FMVs typically send *very* little data to the GS, in some cases
 		// every other frame is nothing more than a page swap.  Sleeping the EEcore is a
@@ -521,7 +468,7 @@ void MTGS::GenericStall(uint size)
 				else
 					freeroom = RingBufferSize - (writepos - readpos);
 
-				if (freeroom > size)
+				if (freeroom > 1)
 					break;
 			}
 		}
@@ -538,63 +485,39 @@ void MTGS::GenericStall(uint size)
 				else
 					freeroom = RingBufferSize - (writepos - readpos);
 
-				if (freeroom > size)
+				if (freeroom > 1)
 					break;
 			}
 		}
 	}
 }
 
-void MTGS::PrepDataPacket(MTGS_RingCommand cmd, u32 size)
-{
-	s_packet_size = size;
-	++size; // takes into account our RingCommand QWC.
-	GenericStall(size);
-
-	// Command qword: Low word is the command, and the high word is the packet
-	// length in SIMDs (128 bits).
-	const unsigned int local_WritePos = s_WritePos.load(std::memory_order_relaxed);
-
-	PacketTagType& tag = (PacketTagType&)RingBuffer.m_Ring[local_WritePos];
-	tag.command        = cmd;
-	tag.data[0]        = s_packet_size;
-	s_packet_startpos  = local_WritePos;
-	s_packet_writepos  = (local_WritePos + 1) & RingBufferMask;
-}
-
 void MTGS::SendSimplePacket(MTGS_RingCommand type, int data0, int data1, int data2)
 {
-	GenericStall(1);
-	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
+       GenericStall();
+       PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
 
-	tag.command          = type;
-	tag.data[0]          = data0;
-	tag.data[1]          = data1;
-	tag.data[2]          = data2;
+       tag.command          = type;
+       tag.data[0]          = data0;
+       tag.data[1]          = data1;
+       tag.data[2]          = data2;
 
-	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
-	s_WritePos.store(future_writepos, std::memory_order_release);
+       uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+       s_WritePos.store(future_writepos, std::memory_order_release);
 
-	++s_CopyDataTally;
+       ++s_CopyDataTally;
 }
 
-void MTGS::SendSimpleGSPacket(MTGS_RingCommand type, u32 offset, u32 size, GIF_PATH path)
-{
-	SendSimplePacket(type, (int)offset, (int)size, (int)path);
 
-	s_CopyDataTally += size / 16;
-	if (s_CopyDataTally > 0x2000)
-		SetEvent();
-}
-
-void MTGS::SendPointerPacket(MTGS_RingCommand type, u32 data0, void* data1)
+void MTGS::SendGameCRC(u32 crc)
 {
-	GenericStall(1);
+	GenericStall();
 	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
 
-	tag.command          = type;
-	tag.data[0]          = data0;
-	tag.pointer          = (uptr)data1;
+	tag.command          = GS_RINGTYPE_CRC;
+	tag.data[0]          = crc;
+	tag.data[1]          = 0;
+	tag.data[2]          = 0;
 
 	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
 	s_WritePos.store(future_writepos, std::memory_order_release);
@@ -602,11 +525,6 @@ void MTGS::SendPointerPacket(MTGS_RingCommand type, u32 data0, void* data1)
 	++s_CopyDataTally;
 }
 
-void MTGS::SendGameCRC(u32 crc)
-{
-	SendSimplePacket(GS_RINGTYPE_CRC, crc, 0, 0);
-}
-
 void MTGS::WaitForClose()
 {
 	// and kick the thread if it's sleeping
@@ -622,15 +540,35 @@ void MTGS::Freeze(FreezeAction mode, MTGS_FreezeData& data)
 {
 	// synchronize regs before loading
 	if (mode == FreezeAction::Load)
-		WaitGS(true);
+		WaitGS(false, false);
 
-	SendPointerPacket(GS_RINGTYPE_FREEZE, (int)mode, &data);
-	WaitGS(false);
+	GenericStall();
+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command          = GS_RINGTYPE_FREEZE;
+	tag.data[0]          = (int)mode;
+	tag.pointer          = (uptr)&data;
+
+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++s_CopyDataTally;
+	WaitGS(false, false);
 }
 
 void MTGS::RunOnGSThread(AsyncCallType func)
 {
-	SendPointerPacket(GS_RINGTYPE_ASYNC_CALL, 0, new AsyncCallType(std::move(func)));
+	GenericStall();
+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command          = GS_RINGTYPE_ASYNC_CALL;
+	tag.data[0]          = 0;
+	tag.pointer          = (uptr)new AsyncCallType(std::move(func));
+
+	uint future_writepos = (s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++s_CopyDataTally;
 
 	// wake the gs thread in case it's sleeping
 	SetEvent();
@@ -646,7 +584,7 @@ void MTGS::ApplySettings()
 	// is unsynchronized, because otherwise we might potentially read in the middle of
 	// the GS renderer being reopened.
 	if (EmuConfig.GS.HWDownloadMode == GSHardwareDownloadMode::Unsynchronized)
-		WaitGS(false, false, false);
+		WaitGS(false, false);
 }
 
 void MTGS::SwitchRenderer(GSRendererType renderer, bool display_message /* = true */)
@@ -657,7 +595,7 @@ void MTGS::SwitchRenderer(GSRendererType renderer, bool display_message /* = tru
 
 	// See note in ApplySettings() for reasoning here.
 	if (EmuConfig.GS.HWDownloadMode == GSHardwareDownloadMode::Unsynchronized)
-		WaitGS(false, false, false);
+		WaitGS(false, false);
 }
 
 void MTGS::SetSoftwareRendering(bool software, bool display_message /* = true */)
@@ -681,18 +619,61 @@ void MTGS::ToggleSoftwareRendering()
 // Used in MTVU mode... MTVU will later complete a real packet
 void Gif_AddGSPacketMTVU(GS_Packet& gsPack, GIF_PATH path)
 {
-	MTGS::SendSimpleGSPacket(GS_RINGTYPE_MTVU_GSPACKET, 0, 0, path);
+	MTGS::GenericStall();
+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[MTGS::s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command          = GS_RINGTYPE_MTVU_GSPACKET;
+	tag.data[0]          = 0;
+	tag.data[1]          = 0;
+	tag.data[2]          = (int)path;
+
+	uint future_writepos = (MTGS::s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	MTGS::s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++MTGS::s_CopyDataTally;
+	if (MTGS::s_CopyDataTally > 0x2000)
+		MTGS::SetEvent();
 }
 
 void Gif_AddCompletedGSPacket(GS_Packet& gsPack, GIF_PATH path)
 {
 	gifUnit.gifPath[path].readAmount.fetch_add(gsPack.size);
-	MTGS::SendSimpleGSPacket(GS_RINGTYPE_GSPACKET, gsPack.offset, gsPack.size, path);
+	MTGS::GenericStall();
+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[MTGS::s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command          = GS_RINGTYPE_GSPACKET;
+	tag.data[0]          = (int)gsPack.offset;
+	tag.data[1]          = (int)gsPack.size;
+	tag.data[2]          = (int)path;
+
+	uint future_writepos = (MTGS::s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	MTGS::s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++MTGS::s_CopyDataTally;
+
+	MTGS::s_CopyDataTally += gsPack.size / 16;
+	if (MTGS::s_CopyDataTally > 0x2000)
+		MTGS::SetEvent();
 }
 
 void Gif_AddBlankGSPacket(u32 size, GIF_PATH path)
 {
 	gifUnit.gifPath[path].readAmount.fetch_add(size);
-	MTGS::SendSimpleGSPacket(GS_RINGTYPE_GSPACKET, ~0u, size, path);
+	MTGS::GenericStall();
+	PacketTagType& tag   = (PacketTagType&)RingBuffer.m_Ring[MTGS::s_WritePos.load(std::memory_order_relaxed)];
+
+	tag.command          = GS_RINGTYPE_GSPACKET;
+	tag.data[0]          = (int)~0u;
+	tag.data[1]          = (int)size;
+	tag.data[2]          = (int)path;
+
+	uint future_writepos = (MTGS::s_WritePos.load(std::memory_order_relaxed) + 1) & RingBufferMask;
+	MTGS::s_WritePos.store(future_writepos, std::memory_order_release);
+
+	++MTGS::s_CopyDataTally;
+
+	MTGS::s_CopyDataTally += size;
+	if (MTGS::s_CopyDataTally > 0x2000)
+		MTGS::SetEvent();
 }
 
diff --git a/pcsx2/VMManager.cpp b/pcsx2/VMManager.cpp
index b5422eced..d4b03f83b 100644
--- a/pcsx2/VMManager.cpp
+++ b/pcsx2/VMManager.cpp
@@ -634,7 +634,7 @@ void VMManager::Shutdown(bool save_resume_state)
 	// sync everything
 	if (THREAD_VU1)
 		vu1Thread.WaitVU();
-	MTGS::WaitGS();
+	MTGS::WaitGS(false, false);
 
 	{
 		LastELF.clear();
@@ -704,7 +704,7 @@ void VMManager::Reset()
 
 	vu1Thread.WaitVU();
 	vu1Thread.Reset();
-	MTGS::WaitGS();
+	MTGS::WaitGS(false, false);
 
 	const bool game_was_started = g_GameStarted;
 
@@ -980,7 +980,7 @@ void VMManager::ApplySettings()
 	{
 		if (THREAD_VU1)
 			vu1Thread.WaitVU();
-		MTGS::WaitGS(false);
+		MTGS::WaitGS(false, false);
 	}
 
 	// Reset to a clean Pcsx2Config. Otherwise things which are optional (e.g. gamefixes)
