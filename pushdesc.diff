diff --git a/3rdparty/wil b/3rdparty/wil
--- a/3rdparty/wil
+++ b/3rdparty/wil
@@ -1 +1 @@
-Subproject commit 3018875eaa4f8e3d86cf2da97fd577bae59f3aec
+Subproject commit 3018875eaa4f8e3d86cf2da97fd577bae59f3aec-dirty
diff --git a/bin/resources/shaders/vulkan/tfx.glsl b/bin/resources/shaders/vulkan/tfx.glsl
index dc7e3a675..9b4811578 100644
--- a/bin/resources/shaders/vulkan/tfx.glsl
+++ b/bin/resources/shaders/vulkan/tfx.glsl
@@ -339,16 +339,16 @@ layout(set = 1, binding = 1) uniform texture2D Palette;
 
 #if PS_FEEDBACK_LOOP_IS_NEEDED
 	#if defined(DISABLE_TEXTURE_BARRIER) || defined(HAS_FEEDBACK_LOOP_LAYOUT)
-		layout(set = 2, binding = 0) uniform texture2D RtSampler;
+		layout(set = 1, binding = 2) uniform texture2D RtSampler;
 		vec4 sample_from_rt() { return texelFetch(RtSampler, ivec2(gl_FragCoord.xy), 0); }
 	#else
-		layout(input_attachment_index = 0, set = 2, binding = 0) uniform subpassInput RtSampler;
+		layout(input_attachment_index = 0, set = 1, binding = 2) uniform subpassInput RtSampler;
 		vec4 sample_from_rt() { return subpassLoad(RtSampler); }
 	#endif
 #endif
 
 #if PS_DATE > 0
-layout(set = 2, binding = 1) uniform texture2D PrimMinTexture;
+layout(set = 1, binding = 3) uniform texture2D PrimMinTexture;
 #endif
 
 #if NEEDS_TEX
diff --git a/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.cpp b/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.cpp
index 50c3774b3..a59faee27 100644
--- a/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.cpp
+++ b/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.cpp
@@ -616,20 +616,6 @@ static void SafeDestroyDescriptorSetLayout(VkDevice dev, VkDescriptorSetLayout&
 			VkFenceCreateInfo fence_info = {VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, nullptr, VK_FENCE_CREATE_SIGNALED_BIT};
 
 			res = vkCreateFence(m_device, &fence_info, nullptr, &resources.fence);
-			if (res != VK_SUCCESS)
-				return false;
-			// TODO: A better way to choose the number of descriptors.
-			VkDescriptorPoolSize pool_sizes[] = {
-				{VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,	MAX_COMBINED_IMAGE_SAMPLER_DESCRIPTORS_PER_FRAME},
-				{VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 		MAX_SAMPLED_IMAGE_DESCRIPTORS_PER_FRAME},
-				{VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,		MAX_STORAGE_IMAGE_DESCRIPTORS_PER_FRAME},
-				{VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,		MAX_INPUT_ATTACHMENT_IMAGE_DESCRIPTORS_PER_FRAME},
-			};
-
-			VkDescriptorPoolCreateInfo pool_create_info = {VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, nullptr, 0,
-				MAX_DESCRIPTOR_SETS_PER_FRAME, static_cast<u32>(std::size(pool_sizes)), pool_sizes};
-
-			res = vkCreateDescriptorPool(m_device, &pool_create_info, nullptr, &resources.descriptor_pool);
 			if (res != VK_SUCCESS)
 				return false;
 
@@ -654,11 +640,6 @@ static void SafeDestroyDescriptorSetLayout(VkDevice dev, VkDescriptorSetLayout&
 				vkDestroyFence(m_device, resources.fence, nullptr);
 				resources.fence = VK_NULL_HANDLE;
 			}
-			if (resources.descriptor_pool != VK_NULL_HANDLE)
-			{
-				vkDestroyDescriptorPool(m_device, resources.descriptor_pool, nullptr);
-				resources.descriptor_pool = VK_NULL_HANDLE;
-			}
 			if (resources.command_buffers[0] != VK_NULL_HANDLE)
 			{
 				vkFreeCommandBuffers(m_device, resources.command_pool,
@@ -778,23 +759,6 @@ static void SafeDestroyDescriptorSetLayout(VkDevice dev, VkDescriptorSetLayout&
 		return buf;
 	}
 
-	VkDescriptorSet GSDeviceVK::AllocateDescriptorSet(VkDescriptorSetLayout set_layout)
-	{
-		VkDescriptorSetAllocateInfo allocate_info = 	{VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
-								 nullptr,
-								 m_frame_resources[m_current_frame].descriptor_pool,
-								 1,
-								 &set_layout};
-
-		VkDescriptorSet descriptor_set;
-		VkResult res = vkAllocateDescriptorSets(vk_init_info.device, &allocate_info, &descriptor_set);
-		// Failing to allocate a descriptor set is not a fatal error, we can
-		// recover by moving to the next command buffer.
-		if (res != VK_SUCCESS)
-			return VK_NULL_HANDLE;
-		return descriptor_set;
-	}
-
 	VkDescriptorSet GSDeviceVK::AllocatePersistentDescriptorSet(VkDescriptorSetLayout set_layout)
 	{
 		VkDescriptorSetAllocateInfo allocate_info = {
@@ -934,9 +898,6 @@ static void SafeDestroyDescriptorSetLayout(VkDevice dev, VkDescriptorSetLayout&
 			VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, nullptr, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, nullptr};
 		vkBeginCommandBuffer(resources.command_buffers[1], &begin_info);
 
-		// Also can do the same for the descriptor pools
-		vkResetDescriptorPool(m_device, resources.descriptor_pool, 0);
-
 		resources.fence_counter = m_next_fence_counter++;
 		resources.init_buffer_used = false;
 
@@ -2172,7 +2133,7 @@ void GSDeviceVK::OMSetRenderTargets(GSTexture* rt, GSTexture* ds, const GSVector
 				if (vkRt->GetLayout() != GSTextureVK::Layout::FeedbackLoop)
 				{
 					// need to update descriptors to reflect the new layout
-					m_dirty_flags |= DIRTY_FLAG_TFX_SAMPLERS_DS;
+					m_dirty_flags |= (DIRTY_FLAG_TFX_TEXTURE_0 << TFX_TEXTURE_RT);
 					vkRt->TransitionToLayout(GSTextureVK::Layout::FeedbackLoop);
 				}
 			}
@@ -2188,7 +2149,7 @@ void GSDeviceVK::OMSetRenderTargets(GSTexture* rt, GSTexture* ds, const GSVector
 			{
 				if (vkDs->GetLayout() != GSTextureVK::Layout::FeedbackLoop)
 				{
-					m_dirty_flags |= DIRTY_FLAG_TFX_SAMPLERS_DS;
+					m_dirty_flags |= (DIRTY_FLAG_TFX_TEXTURE_0 << TFX_TEXTURE_TEXTURE);
 					vkDs->TransitionToLayout(GSTextureVK::Layout::FeedbackLoop);
 				}
 			}
@@ -2196,7 +2157,6 @@ void GSDeviceVK::OMSetRenderTargets(GSTexture* rt, GSTexture* ds, const GSVector
 			{
 				vkDs->TransitionToLayout(GSTextureVK::Layout::DepthStencilAttachment);
 			}
-
 		}
 	}
 
@@ -2402,7 +2362,8 @@ bool GSDeviceVK::CreatePipelineLayouts()
 	// Convert Pipeline Layout
 	//////////////////////////////////////////////////////////////////////////
 
-	dslb.AddBinding(0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, NUM_CONVERT_SAMPLERS, VK_SHADER_STAGE_FRAGMENT_BIT);
+	dslb.SetPushFlag();
+	dslb.AddBinding(0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, NUM_UTILITY_SAMPLERS, VK_SHADER_STAGE_FRAGMENT_BIT);
 	if ((m_utility_ds_layout = dslb.Create(dev)) == VK_NULL_HANDLE)
 		return false;
 
@@ -2421,22 +2382,20 @@ bool GSDeviceVK::CreatePipelineLayouts()
 		dslb.AddBinding(2, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 1, VK_SHADER_STAGE_VERTEX_BIT);
 	if ((m_tfx_ubo_ds_layout = dslb.Create(dev)) == VK_NULL_HANDLE)
 		return false;
-	dslb.AddBinding(0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
-	dslb.AddBinding(1, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
-	if ((m_tfx_sampler_ds_layout = dslb.Create(dev)) == VK_NULL_HANDLE)
-		return false;
-	dslb.AddBinding(0,
-		(m_features.texture_barrier && !m_has_feedback_loop_layout) 
-		? VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT 
-		: VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
+
+	dslb.SetPushFlag();
+	dslb.AddBinding(TFX_TEXTURE_TEXTURE, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
+	dslb.AddBinding(TFX_TEXTURE_PALETTE, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
+	dslb.AddBinding(TFX_TEXTURE_RT,
+		(m_features.texture_barrier && !UseFeedbackLoopLayout()) ? VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT :
+																   VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
 		1, VK_SHADER_STAGE_FRAGMENT_BIT);
-	dslb.AddBinding(1, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
-	if ((m_tfx_rt_texture_ds_layout = dslb.Create(dev)) == VK_NULL_HANDLE)
+	dslb.AddBinding(TFX_TEXTURE_PRIMID, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
+	if ((m_tfx_texture_ds_layout = dslb.Create(dev)) == VK_NULL_HANDLE)
 		return false;
 
 	plb.AddDescriptorSet(m_tfx_ubo_ds_layout);
-	plb.AddDescriptorSet(m_tfx_sampler_ds_layout);
-	plb.AddDescriptorSet(m_tfx_rt_texture_ds_layout);
+	plb.AddDescriptorSet(m_tfx_texture_ds_layout);
 	if ((m_tfx_pipeline_layout = plb.Create(dev)) == VK_NULL_HANDLE)
 		return false;
 	return true;
@@ -2958,8 +2917,7 @@ void GSDeviceVK::DestroyResources()
 	}
 
 	SafeDestroyPipelineLayout(m_device, m_tfx_pipeline_layout);
-	SafeDestroyDescriptorSetLayout(m_device, m_tfx_rt_texture_ds_layout);
-	SafeDestroyDescriptorSetLayout(m_device, m_tfx_sampler_ds_layout);
+	SafeDestroyDescriptorSetLayout(m_device, m_tfx_texture_ds_layout);
 	SafeDestroyDescriptorSetLayout(m_device, m_tfx_ubo_ds_layout);
 	SafeDestroyPipelineLayout(m_device, m_utility_pipeline_layout);
 	SafeDestroyDescriptorSetLayout(m_device, m_utility_ds_layout);
@@ -3278,11 +3236,9 @@ void GSDeviceVK::ExecuteCommandBufferAndRestartRenderPass(bool wait_for_completi
 
 void GSDeviceVK::InvalidateCachedState()
 {
-	m_dirty_flags |= DIRTY_FLAG_TFX_SAMPLERS_DS | DIRTY_FLAG_TFX_RT_TEXTURE_DS | DIRTY_FLAG_TFX_DYNAMIC_OFFSETS |
-					 DIRTY_FLAG_UTILITY_TEXTURE | DIRTY_FLAG_BLEND_CONSTANTS | DIRTY_FLAG_LINE_WIDTH |
-					 DIRTY_FLAG_INDEX_BUFFER | DIRTY_FLAG_VIEWPORT | DIRTY_FLAG_SCISSOR | DIRTY_FLAG_PIPELINE |
-					 DIRTY_FLAG_VS_CONSTANT_BUFFER | DIRTY_FLAG_PS_CONSTANT_BUFFER;
-
+	m_dirty_flags = ALL_DIRTY_STATE;
+	if (m_index_buffer != VK_NULL_HANDLE)
+		m_dirty_flags |= DIRTY_FLAG_INDEX_BUFFER;
 	for (u32 i = 0; i < NUM_TFX_TEXTURES; i++)
 		m_tfx_textures[i] = m_null_texture.get();
 	m_utility_texture = m_null_texture.get();
@@ -3346,8 +3302,7 @@ void GSDeviceVK::PSSetShaderResource(int i, GSTexture* sr, bool check_state)
 		return;
 
 	m_tfx_textures[i] = vkTex;
-
-	m_dirty_flags |= (i < 2) ? DIRTY_FLAG_TFX_SAMPLERS_DS : DIRTY_FLAG_TFX_RT_TEXTURE_DS;
+	m_dirty_flags |= (DIRTY_FLAG_TFX_TEXTURE_0 << i);
 }
 
 void GSDeviceVK::PSSetSampler(GSHWDrawConfig::SamplerSelector sel)
@@ -3357,7 +3312,7 @@ void GSDeviceVK::PSSetSampler(GSHWDrawConfig::SamplerSelector sel)
 
 	m_tfx_sampler_sel = sel.key;
 	m_tfx_sampler = GetSampler(sel);
-	m_dirty_flags |= DIRTY_FLAG_TFX_SAMPLERS_DS;
+	m_dirty_flags |= DIRTY_FLAG_TFX_TEXTURE_0;
 }
 
 void GSDeviceVK::SetUtilityTexture(GSTexture* tex, VkSampler sampler)
@@ -3393,7 +3348,7 @@ void GSDeviceVK::UnbindTexture(GSTextureVK* tex)
 		if (m_tfx_textures[i] == tex)
 		{
 			m_tfx_textures[i] = m_null_texture.get();
-			m_dirty_flags |= (i < 2) ? DIRTY_FLAG_TFX_SAMPLERS_DS : DIRTY_FLAG_TFX_RT_TEXTURE_DS;
+			m_dirty_flags |= (DIRTY_FLAG_TFX_TEXTURE_0 << i);
 		}
 	}
 	if (m_utility_texture == tex)
@@ -3533,16 +3488,15 @@ bool GSDeviceVK::ApplyTFXState(bool already_execed)
 	if (m_current_pipeline_layout == PipelineLayout::TFX && m_dirty_flags == 0)
 		return true;
 
-	const VkDevice dev           = vk_init_info.device;
 	const VkCommandBuffer cmdbuf = GetCurrentCommandBuffer();
 	u32 flags = m_dirty_flags;
-	m_dirty_flags &= ~(DIRTY_TFX_STATE | DIRTY_CONSTANT_BUFFER_STATE | DIRTY_FLAG_TFX_DYNAMIC_OFFSETS);
+	m_dirty_flags &= ~(DIRTY_TFX_STATE | DIRTY_CONSTANT_BUFFER_STATE | DIRTY_FLAG_TFX_UBO);
 
 	// do cbuffer first, because it's the most likely to cause an exec
 	if (flags & DIRTY_FLAG_VS_CONSTANT_BUFFER)
 	{
 		if (!m_vertex_uniform_stream_buffer.ReserveMemory(
-				sizeof(m_vs_cb_cache), GetUniformBufferAlignment()))
+				sizeof(m_vs_cb_cache), static_cast<u32>(m_device_properties.limits.minUniformBufferOffsetAlignment)))
 		{
 			if (already_execed)
 			{
@@ -3558,13 +3512,13 @@ bool GSDeviceVK::ApplyTFXState(bool already_execed)
 		memcpy(m_vertex_uniform_stream_buffer.GetCurrentHostPointer(), &m_vs_cb_cache, sizeof(m_vs_cb_cache));
 		m_tfx_dynamic_offsets[0] = m_vertex_uniform_stream_buffer.GetCurrentOffset();
 		m_vertex_uniform_stream_buffer.CommitMemory(sizeof(m_vs_cb_cache));
-		flags |= DIRTY_FLAG_TFX_DYNAMIC_OFFSETS;
+		flags |= DIRTY_FLAG_TFX_UBO;
 	}
 
 	if (flags & DIRTY_FLAG_PS_CONSTANT_BUFFER)
 	{
 		if (!m_fragment_uniform_stream_buffer.ReserveMemory(
-				sizeof(m_ps_cb_cache), GetUniformBufferAlignment()))
+				sizeof(m_ps_cb_cache), static_cast<u32>(m_device_properties.limits.minUniformBufferOffsetAlignment)))
 		{
 			if (already_execed)
 			{
@@ -3580,120 +3534,62 @@ bool GSDeviceVK::ApplyTFXState(bool already_execed)
 		memcpy(m_fragment_uniform_stream_buffer.GetCurrentHostPointer(), &m_ps_cb_cache, sizeof(m_ps_cb_cache));
 		m_tfx_dynamic_offsets[1] = m_fragment_uniform_stream_buffer.GetCurrentOffset();
 		m_fragment_uniform_stream_buffer.CommitMemory(sizeof(m_ps_cb_cache));
-		flags |= DIRTY_FLAG_TFX_DYNAMIC_OFFSETS;
+		flags |= DIRTY_FLAG_TFX_UBO;
 	}
 
 	Vulkan::DescriptorSetUpdateBuilder dsub;
-
-	VkDescriptorSet dsets[NUM_TFX_DESCRIPTOR_SETS];
-	u32 num_dsets = 0;
-	u32 start_dset = 0;
-	const bool layout_changed = (m_current_pipeline_layout != PipelineLayout::TFX);
-
-	if (!layout_changed && flags & DIRTY_FLAG_TFX_DYNAMIC_OFFSETS)
-		dsets[num_dsets++] = m_tfx_ubo_descriptor_set;
-
-	if ((flags & DIRTY_FLAG_TFX_SAMPLERS_DS) || m_tfx_texture_descriptor_set == VK_NULL_HANDLE)
+	if (m_current_pipeline_layout != PipelineLayout::TFX)
 	{
-		m_tfx_texture_descriptor_set = AllocateDescriptorSet(m_tfx_sampler_ds_layout);
-		if (m_tfx_texture_descriptor_set == VK_NULL_HANDLE)
-		{
-			if (already_execed)
-			{
-				Console.Error("Failed to allocate TFX texture descriptors");
-				return false;
-			}
-
-			/* Ran out of TFX texture descriptors */
-			ExecuteCommandBufferAndRestartRenderPass(false);
-			return ApplyTFXState(true);
-		}
-
-		dsub.AddCombinedImageSamplerDescriptorWrite(
-			m_tfx_texture_descriptor_set, 0, m_tfx_textures[0]->GetView(), m_tfx_sampler, m_tfx_textures[0]->GetVkLayout());
-		dsub.AddImageDescriptorWrite(m_tfx_texture_descriptor_set, 1, m_tfx_textures[1]->GetView(), m_tfx_textures[1]->GetVkLayout());
-		dsub.Update(dev);
+		m_current_pipeline_layout = PipelineLayout::TFX;
+		flags |= DIRTY_FLAG_TFX_UBO | DIRTY_FLAG_TFX_TEXTURES;
 
-		if (!layout_changed)
-		{
-			start_dset = (num_dsets == 0) ?
-				TFX_DESCRIPTOR_SET_TEXTURES : start_dset;
-			dsets[num_dsets++] = m_tfx_texture_descriptor_set;
-		}
+		// Clear out the RT binding if feedback loop isn't on, because it'll be in the wrong state and make
+		// the validation layer cranky. Not a big deal since we need to write it anyway.
+		const GSTextureVK::Layout rt_tex_layout = m_tfx_textures[TFX_TEXTURE_RT]->GetLayout();
+		if (rt_tex_layout != GSTextureVK::Layout::FeedbackLoop && rt_tex_layout != GSTextureVK::Layout::ShaderReadOnly)
+			m_tfx_textures[TFX_TEXTURE_RT] = m_null_texture.get();
 	}
 
-	if ((flags & DIRTY_FLAG_TFX_RT_TEXTURE_DS) || m_tfx_rt_descriptor_set == VK_NULL_HANDLE)
+	if (flags & DIRTY_FLAG_TFX_UBO)
 	{
-		m_tfx_rt_descriptor_set = AllocateDescriptorSet(m_tfx_rt_texture_ds_layout);
-		if (m_tfx_rt_descriptor_set == VK_NULL_HANDLE)
-		{
-			if (already_execed)
-			{
-				Console.Error("Failed to allocate TFX sampler descriptors");
-				return false;
-			}
-
-			/* Ran out of TFX sampler descriptors */
-			ExecuteCommandBufferAndRestartRenderPass(false);
-			return ApplyTFXState(true);
-		}
+		// Still need to bind the UBO descriptor set.
+		vkCmdBindDescriptorSets(cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, m_tfx_pipeline_layout, 0, 1,
+			&m_tfx_ubo_descriptor_set, NUM_TFX_DYNAMIC_OFFSETS, m_tfx_dynamic_offsets.data());
+	}
 
-		if (m_features.texture_barrier && !m_has_feedback_loop_layout)
+	if (flags & DIRTY_FLAG_TFX_TEXTURES)
+	{
+		if (flags & DIRTY_FLAG_TFX_TEXTURE_TEX)
 		{
-			dsub.AddInputAttachmentDescriptorWrite(
-				m_tfx_rt_descriptor_set, 0, m_tfx_textures[NUM_TFX_DRAW_TEXTURES]->GetView(), VK_IMAGE_LAYOUT_GENERAL);
+			dsub.AddCombinedImageSamplerDescriptorWrite(VK_NULL_HANDLE, TFX_TEXTURE_TEXTURE,
+				m_tfx_textures[TFX_TEXTURE_TEXTURE]->GetView(), m_tfx_sampler,
+				m_tfx_textures[TFX_TEXTURE_TEXTURE]->GetVkLayout());
 		}
-		else
+		if (flags & DIRTY_FLAG_TFX_TEXTURE_PALETTE)
 		{
-			dsub.AddImageDescriptorWrite(m_tfx_rt_descriptor_set, 0, m_tfx_textures[NUM_TFX_DRAW_TEXTURES]->GetView(),
-				m_tfx_textures[NUM_TFX_DRAW_TEXTURES]->GetVkLayout());
+			dsub.AddImageDescriptorWrite(VK_NULL_HANDLE, TFX_TEXTURE_PALETTE,
+				m_tfx_textures[TFX_TEXTURE_PALETTE]->GetView(), m_tfx_textures[TFX_TEXTURE_PALETTE]->GetVkLayout());
 		}
-		dsub.AddImageDescriptorWrite(m_tfx_rt_descriptor_set, 1, m_tfx_textures[NUM_TFX_DRAW_TEXTURES + 1]->GetView(),
-			m_tfx_textures[NUM_TFX_DRAW_TEXTURES + 1]->GetVkLayout());
-		dsub.Update(dev);
-
-		if (!layout_changed)
+		if (flags & DIRTY_FLAG_TFX_TEXTURE_RT)
 		{
-			// need to add textures in, can't leave a gap
-			if (start_dset == TFX_DESCRIPTOR_SET_UBO && num_dsets == 1)
-				dsets[num_dsets++] = m_tfx_texture_descriptor_set;
+			if (m_features.texture_barrier && !UseFeedbackLoopLayout())
+			{
+				dsub.AddInputAttachmentDescriptorWrite(
+					VK_NULL_HANDLE, TFX_TEXTURE_RT, m_tfx_textures[TFX_TEXTURE_RT]->GetView(), VK_IMAGE_LAYOUT_GENERAL);
+			}
 			else
-				start_dset = (num_dsets == 0) ? TFX_DESCRIPTOR_SET_RT : start_dset;
-
-			dsets[num_dsets++] = m_tfx_rt_descriptor_set;
-		}
-	}
-
-	if (layout_changed)
-	{
-		m_current_pipeline_layout = PipelineLayout::TFX;
-
-		dsets[0] = m_tfx_ubo_descriptor_set;
-		dsets[1] = m_tfx_texture_descriptor_set;
-		dsets[2] = m_tfx_rt_descriptor_set;
-
-		vkCmdBindDescriptorSets(cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, m_tfx_pipeline_layout, 0,
-			NUM_TFX_DESCRIPTOR_SETS, dsets, NUM_TFX_DYNAMIC_OFFSETS,
-			m_tfx_dynamic_offsets.data());
-	}
-	else if (num_dsets > 0)
-	{
-		u32 dynamic_count;
-		const u32* dynamic_offsets;
-		if (start_dset == TFX_DESCRIPTOR_SET_UBO)
-		{
-			dynamic_count   = NUM_TFX_DYNAMIC_OFFSETS;
-			dynamic_offsets = m_tfx_dynamic_offsets.data();
+			{
+				dsub.AddImageDescriptorWrite(VK_NULL_HANDLE, TFX_TEXTURE_RT, m_tfx_textures[TFX_TEXTURE_RT]->GetView(),
+					m_tfx_textures[TFX_TEXTURE_RT]->GetVkLayout());
+			}
 		}
-		else
+		if (flags & DIRTY_FLAG_TFX_TEXTURE_PRIMID)
 		{
-			dynamic_count = 0;
-			dynamic_offsets = nullptr;
+			dsub.AddImageDescriptorWrite(VK_NULL_HANDLE, TFX_TEXTURE_PRIMID,
+				m_tfx_textures[TFX_TEXTURE_PRIMID]->GetView(), m_tfx_textures[TFX_TEXTURE_PRIMID]->GetVkLayout());
 		}
 
-		vkCmdBindDescriptorSets(cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, m_tfx_pipeline_layout, start_dset, num_dsets,
-			dsets, dynamic_count,
-			dynamic_offsets);
+		dsub.PushUpdate(cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, m_tfx_pipeline_layout, TFX_DESCRIPTOR_SET_TEXTURES);
 	}
 
 
@@ -3711,39 +3607,16 @@ bool GSDeviceVK::ApplyUtilityState(bool already_execed)
 	u32 flags                    = m_dirty_flags;
 	m_dirty_flags               &= ~DIRTY_UTILITY_STATE;
 
-	bool rebind                  = (m_current_pipeline_layout != PipelineLayout::Utility);
-
-	if ((flags & DIRTY_FLAG_UTILITY_TEXTURE) || m_utility_descriptor_set == VK_NULL_HANDLE)
+	if (m_current_pipeline_layout != PipelineLayout::Utility || flags & DIRTY_FLAG_UTILITY_TEXTURE)
 	{
-		m_utility_descriptor_set = AllocateDescriptorSet(m_utility_ds_layout);
-		if (m_utility_descriptor_set == VK_NULL_HANDLE)
-		{
-			if (already_execed)
-			{
-				Console.Error("Failed to allocate utility descriptors");
-				return false;
-			}
-
-			/* Ran out of utility descriptors */
-			ExecuteCommandBufferAndRestartRenderPass(false);
-			return ApplyUtilityState(true);
-		}
+		m_current_pipeline_layout = PipelineLayout::Utility;
 
 		Vulkan::DescriptorSetUpdateBuilder dsub;
-		dsub.AddCombinedImageSamplerDescriptorWrite(m_utility_descriptor_set, 0, m_utility_texture->GetView(),
-			m_utility_sampler, m_utility_texture->GetVkLayout());
-		dsub.Update(dev);
-		rebind = true;
-	}
-
-	if (rebind)
-	{
-		vkCmdBindDescriptorSets(cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, m_utility_pipeline_layout, 0, 1,
-			&m_utility_descriptor_set, 0, nullptr);
+		dsub.AddCombinedImageSamplerDescriptorWrite(
+				VK_NULL_HANDLE, 0, m_utility_texture->GetView(), m_utility_sampler, m_utility_texture->GetVkLayout());
+		dsub.PushUpdate(cmdbuf, VK_PIPELINE_BIND_POINT_GRAPHICS, m_utility_pipeline_layout, 0, false);
 	}
 
-	m_current_pipeline_layout = PipelineLayout::Utility;
-
 	ApplyBaseState(flags, cmdbuf);
 	return true;
 }
@@ -4026,7 +3899,7 @@ void GSDeviceVK::RenderHW(GSHWDrawConfig& config)
 
 		// If this is the first draw to the target as a feedback loop, make sure we re-generate the texture descriptor.
 		// Otherwise, we might have a previous descriptor left over, that has the RT in a different state.
-		m_dirty_flags |= (skip_first_barrier ? DIRTY_FLAG_TFX_RT_TEXTURE_DS : 0);
+		m_dirty_flags |= (skip_first_barrier ? static_cast<u32>(DIRTY_FLAG_TFX_TEXTURE_RT) : 0);
 	}
 
 	// Begin render pass if new target or out of the area.
diff --git a/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.h b/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.h
index 827473d9c..54d572c15 100644
--- a/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.h
+++ b/pcsx2/GS/Renderers/Vulkan/GSDeviceVK.h
@@ -120,11 +120,7 @@ public:
 	enum : u32
 	{
 		NUM_TFX_DYNAMIC_OFFSETS = 2,
-		NUM_TFX_DRAW_TEXTURES = 2,
-		NUM_TFX_RT_TEXTURES = 2,
-		NUM_TFX_TEXTURES = NUM_TFX_DRAW_TEXTURES + NUM_TFX_RT_TEXTURES,
-		NUM_CONVERT_TEXTURES = 1,
-		NUM_CONVERT_SAMPLERS = 1,
+		NUM_UTILITY_SAMPLERS = 1,
 		CONVERT_PUSH_CONSTANTS_SIZE = 96,
 
 		VERTEX_BUFFER_SIZE = 32 * 1024 * 1024,
@@ -136,10 +132,18 @@ public:
 	{
 		TFX_DESCRIPTOR_SET_UBO,
 		TFX_DESCRIPTOR_SET_TEXTURES,
-		TFX_DESCRIPTOR_SET_RT,
 
 		NUM_TFX_DESCRIPTOR_SETS,
 	};
+	enum TFX_TEXTURES : u32
+	{
+		TFX_TEXTURE_TEXTURE,
+		TFX_TEXTURE_PALETTE,
+		TFX_TEXTURE_RT,
+		TFX_TEXTURE_PRIMID,
+
+		NUM_TFX_TEXTURES
+	};
 	enum DATE_RENDER_PASS : u32
 	{
 		DATE_RENDER_PASS_NONE = 0,
@@ -210,9 +214,6 @@ public:
        __fi VKStreamBuffer& GetTextureUploadBuffer() { return m_texture_upload_buffer; }
        VkCommandBuffer GetCurrentInitCommandBuffer();
 
-       /// Allocates a descriptor set from the pool reserved for the current frame.
-       VkDescriptorSet AllocateDescriptorSet(VkDescriptorSetLayout set_layout);
-
        /// Allocates a descriptor set from the pool reserved for the current frame.
        VkDescriptorSet AllocatePersistentDescriptorSet(VkDescriptorSetLayout set_layout);
 
@@ -299,7 +300,6 @@ private:
 	       // [0] - Init (upload) command buffer, [1] - draw command buffer
 	       VkCommandPool command_pool = VK_NULL_HANDLE;
 	       std::array<VkCommandBuffer, 2> command_buffers{VK_NULL_HANDLE, VK_NULL_HANDLE};
-	       VkDescriptorPool descriptor_pool = VK_NULL_HANDLE;
 	       VkFence fence = VK_NULL_HANDLE;
 	       u64 fence_counter = 0;
 	       bool init_buffer_used = false;
@@ -335,8 +335,7 @@ private:
 	VkPipelineLayout m_utility_pipeline_layout = VK_NULL_HANDLE;
 
 	VkDescriptorSetLayout m_tfx_ubo_ds_layout = VK_NULL_HANDLE;
-	VkDescriptorSetLayout m_tfx_sampler_ds_layout = VK_NULL_HANDLE;
-	VkDescriptorSetLayout m_tfx_rt_texture_ds_layout = VK_NULL_HANDLE;
+	VkDescriptorSetLayout m_tfx_texture_ds_layout = VK_NULL_HANDLE;
 	VkPipelineLayout m_tfx_pipeline_layout = VK_NULL_HANDLE;
 
 	VKStreamBuffer m_vertex_stream_buffer;
@@ -529,24 +528,34 @@ public:
 private:
 	enum DIRTY_FLAG : u32
 	{
-		DIRTY_FLAG_TFX_SAMPLERS_DS = (1 << 0),
-		DIRTY_FLAG_TFX_RT_TEXTURE_DS = (1 << 1),
-		DIRTY_FLAG_TFX_DYNAMIC_OFFSETS = (1 << 2),
-		DIRTY_FLAG_UTILITY_TEXTURE = (1 << 3),
-		DIRTY_FLAG_BLEND_CONSTANTS = (1 << 4),
-		DIRTY_FLAG_LINE_WIDTH = (1 << 5),
-		DIRTY_FLAG_INDEX_BUFFER = (1 << 6),
-		DIRTY_FLAG_VIEWPORT = (1 << 7),
-		DIRTY_FLAG_SCISSOR = (1 << 8),
-		DIRTY_FLAG_PIPELINE = (1 << 9),
-		DIRTY_FLAG_VS_CONSTANT_BUFFER = (1 << 10),
-		DIRTY_FLAG_PS_CONSTANT_BUFFER = (1 << 11),
-
-		DIRTY_BASE_STATE = DIRTY_FLAG_INDEX_BUFFER | DIRTY_FLAG_PIPELINE |
-						   DIRTY_FLAG_VIEWPORT | DIRTY_FLAG_SCISSOR | DIRTY_FLAG_BLEND_CONSTANTS | DIRTY_FLAG_LINE_WIDTH,
-		DIRTY_TFX_STATE = DIRTY_BASE_STATE | DIRTY_FLAG_TFX_SAMPLERS_DS | DIRTY_FLAG_TFX_RT_TEXTURE_DS,
+		DIRTY_FLAG_TFX_TEXTURE_0 = (1 << 0), // 0, 1, 2, 3
+		DIRTY_FLAG_TFX_UBO = (1 << 4),
+		DIRTY_FLAG_UTILITY_TEXTURE = (1 << 5),
+		DIRTY_FLAG_BLEND_CONSTANTS = (1 << 6),
+		DIRTY_FLAG_LINE_WIDTH = (1 << 7),
+		DIRTY_FLAG_VERTEX_BUFFER = (1 << 8),
+		DIRTY_FLAG_INDEX_BUFFER = (1 << 9),
+		DIRTY_FLAG_VIEWPORT = (1 << 10),
+		DIRTY_FLAG_SCISSOR = (1 << 11),
+		DIRTY_FLAG_PIPELINE = (1 << 12),
+		DIRTY_FLAG_VS_CONSTANT_BUFFER = (1 << 13),
+		DIRTY_FLAG_PS_CONSTANT_BUFFER = (1 << 14),
+
+		DIRTY_FLAG_TFX_TEXTURE_TEX = (DIRTY_FLAG_TFX_TEXTURE_0 << 0),
+		DIRTY_FLAG_TFX_TEXTURE_PALETTE = (DIRTY_FLAG_TFX_TEXTURE_0 << 1),
+		DIRTY_FLAG_TFX_TEXTURE_RT = (DIRTY_FLAG_TFX_TEXTURE_0 << 2),
+		DIRTY_FLAG_TFX_TEXTURE_PRIMID = (DIRTY_FLAG_TFX_TEXTURE_0 << 3),
+
+		DIRTY_FLAG_TFX_TEXTURES = DIRTY_FLAG_TFX_TEXTURE_TEX | DIRTY_FLAG_TFX_TEXTURE_PALETTE |
+								  DIRTY_FLAG_TFX_TEXTURE_RT | DIRTY_FLAG_TFX_TEXTURE_PRIMID,
+
+		DIRTY_BASE_STATE = DIRTY_FLAG_VERTEX_BUFFER | DIRTY_FLAG_INDEX_BUFFER | DIRTY_FLAG_PIPELINE |
+						   DIRTY_FLAG_VIEWPORT | DIRTY_FLAG_SCISSOR | DIRTY_FLAG_BLEND_CONSTANTS |
+						   DIRTY_FLAG_LINE_WIDTH,
+		DIRTY_TFX_STATE = DIRTY_BASE_STATE | DIRTY_FLAG_TFX_TEXTURES,
 		DIRTY_UTILITY_STATE = DIRTY_BASE_STATE | DIRTY_FLAG_UTILITY_TEXTURE,
 		DIRTY_CONSTANT_BUFFER_STATE = DIRTY_FLAG_VS_CONSTANT_BUFFER | DIRTY_FLAG_PS_CONSTANT_BUFFER,
+		ALL_DIRTY_STATE = DIRTY_BASE_STATE | DIRTY_TFX_STATE | DIRTY_UTILITY_STATE | DIRTY_CONSTANT_BUFFER_STATE,
 	};
 
 	enum class PipelineLayout
